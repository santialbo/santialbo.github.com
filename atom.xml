<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Santi Albo]]></title>
  <link href="http://santialbo.com/atom.xml" rel="self"/>
  <link href="http://santialbo.com/"/>
  <updated>2013-06-18T13:49:25+02:00</updated>
  <id>http://santialbo.com/</id>
  <author>
    <name><![CDATA[Santi Albo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Monads in F#]]></title>
    <link href="http://santialbo.com/blog/2013/03/27/monads-in-f-sharp/"/>
    <updated>2013-03-27T16:04:00+01:00</updated>
    <id>http://santialbo.com/blog/2013/03/27/monads-in-f-sharp</id>
    
    <category><![CDATA[F#]]></category>
    
    <category><![CDATA[Functional programming]]></category>
    
    <category><![CDATA[Monads]]></category>
    
    <category><![CDATA[Parser combinators]]></category>
    
    
    
    <summary><![CDATA[When I first tried to learn what monads were, I probably made the mistake of going to wikipedia, which only made things worse. It was not until I began to play with parser combinators that I started to grasp the concept. What are monads? You probably heard the word monad &hellip;]]></summary>
    
    <content type="html"><![CDATA[<p>When I first tried to learn what monads were, I probably made the mistake of going to wikipedia, which only made things worse. It was not until I began to play with <a href="http://santialbo.com/blog/2013/03/24/introduction-to-parser-combinators/">parser combinators</a> that I started to grasp the concept.</p>

<h3>What are monads?</h3>

<p>You probably heard the word <em>monad</em> if you have dealt with functional programming.
However, to me the word is rather obscure, and might sound a little daunting to people starting in functional programming. This is one of the reasons why the creators of F# decided to avoid this term and use the word <em>workflow</em> or <em>computation expression</em> instead.</p>

<p><em>Ok&#8230; but what are they?</em></p>

<p>Basically, monads are just a typeclass and two fundamental operations associated. Think of a generic interface with two abstract methods. These operations have the following syntax:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="nc">Return</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">M</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="nc">Bind</span><span class="o">:</span> <span class="nc">M</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">M</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span> <span class="o">-&gt;</span> <span class="nc">M</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<p>If you have a type <code>M&lt;'a&gt;</code> and two methods with those signatures, then you&#8217;ve got a monad. (Actually there are <a href="http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#Monad_laws">a couple rules</a> these two methods must obey, but we will skip them since they might complicate things.)</p>

<p>The classical example is the <em>Maybe</em>/<em>Option</em> monad. In F#, it can be defined as follows:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">// Note that type annotations are optional. I made them explicity for clarity.</span>
</span><span class='line'><span class="k">type</span> <span class="nc">Maybe</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Just</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Nothing</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="nc">Return</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Maybe</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="nc">Bind</span> <span class="o">(</span><span class="n">mx</span><span class="o">:</span> <span class="nc">Maybe</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">Maybe</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span> <span class="o">:</span> <span class="nc">Maybe</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">mx</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Nothing</span> <span class="o">-&gt;</span> <span class="nc">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p>which may suffice within the pages of a textbook, but it didn&#8217;t make things any clearer to me. Instead, I am going to explain how the usage of monads makes a lot of sense when dealing parser combinators. (If you want to keep reading about the Maybe monad example you can go to <a href="http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#Motivating_examples">the wikipedia entry about monads</a>).</p>

<h3>Monads and parser combinators</h3>

<p>If you don&#8217;t know what parser combinators are, you can read <a href="http://santialbo.com/blog/2013/03/24/introduction-to-parser-combinators/">my previous blog post</a> to get a quick overview.</p>

<p>So we have the following type definition:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">ParserResult</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Success</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="kt">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Failure</span>
</span><span class='line'>
</span><span class='line'><span class="k">type</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="nc">ParserResult</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>That means that a <code>Parser</code> is just a function that takes a list of characters and returns a <code>ParserResult&lt;'a&gt;</code>, which can be either a <code>Failure</code> if nothing could be parsed or a <code>Success</code> otherwise, returning both the parsed element and the rest of the list.</p>

<p>Now that we have the typeclass <code>Parser</code>, we only need to define the associated <code>Return</code> and <code>Bind</code> operations:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="nc">Return</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">):</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">p</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">stream</span><span class="o">)</span>
</span><span class='line'>    <span class="k">in</span> <span class="n">p</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="nc">Bind</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">q</span> <span class="n">stream</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">match</span> <span class="n">p</span> <span class="n">stream</span> <span class="k">with</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="n">rest</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">Failure</span> <span class="o">-&gt;</span> <span class="nc">Failure</span>
</span><span class='line'>    <span class="k">in</span> <span class="n">q</span>
</span></code></pre></td></tr></table></div></figure>


<p>TA-DAA! There&#8217;s a monad. It is standard notation, though, to use the operator <code>&gt;&gt;=</code> for the <code>Bind</code> operation. We can define it too:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="o">(&gt;&gt;=)</span> <span class="o">=</span> <span class="nc">Bind</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>Cool, but how is this useful?</em></p>

<p>Those functions we just defined allow us to define the following parser combinators in a very concise way:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// If parser p succeeds, returns x as a result.</span>
</span><span class='line'><span class="k">let</span> <span class="o">(&gt;&gt;%)</span> <span class="n">p</span> <span class="n">x</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Return</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Applies parsers p1 and p2, returning the result of p2.</span>
</span><span class='line'><span class="k">let</span> <span class="o">(&gt;&gt;.)</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">p1</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">p2</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Applies parsers p1 and p2, returning the result of p1.</span>
</span><span class='line'><span class="k">let</span> <span class="o">(.&gt;&gt;)</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">p1</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;%</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Applies parsers p1 and p2, returning both results.</span>
</span><span class='line'><span class="k">let</span> <span class="o">(.&gt;&gt;.)</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">*</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">p1</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nc">Return</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that the <em>Bind</em> operator <code>&gt;&gt;=</code> is used twice in the definition of the <code>.&gt;&gt;.</code> operator. Unfortunately, this gets harder to read as the complexity of parsers increases. This is why Haskell introduced the <em>do-notation</em> (<em>perform-notation</em> in OCaml or <em>computation expressions</em> in F#), which is a syntactic sugar that tries to mimick the imperative-style laguages. Basically, it allows you to write a series of simple <em>statements</em> instead of a nested series of <code>&gt;&gt;=</code> operations.</p>

<h3>Workflows</h3>

<p>In order to use the F#&#8217;s equivalent to the <em>do-notation</em>, we need to create a <em>workflow builder</em>. Workflow builders are just an interface that we have to implement. Two methods are required; the rest are optional. These two methods are <code>Return</code> and <code>Bind</code> as you might have guessed. This is how we can define the <code>parse</code> workflow:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">// Note that we previously defined Bind and Return.</span>
</span><span class='line'><span class="k">type</span> <span class="nc">ParserBuilder</span><span class="bp">()</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">member</span> <span class="n">x</span><span class="o">.</span><span class="nc">Bind</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="o">=</span> <span class="nc">Bind</span> <span class="n">p</span> <span class="n">f</span>
</span><span class='line'>    <span class="k">member</span> <span class="n">x</span><span class="o">.</span><span class="nc">Return</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">=</span> <span class="nc">Return</span> <span class="n">y</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">parse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParserBuilder</span><span class="bp">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>and this is how we use it to define the <code>Many</code> parser combinator in a more readable way than thre previous blog post.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">// This is the Either combinator defined in the previous blog post.</span>
</span><span class='line'><span class="k">let</span> <span class="o">(&lt;|&gt;)</span> <span class="o">=</span> <span class="nc">Either</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="nc">Many</span> <span class="n">p</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="kt">list</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">parse</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">let</span><span class="o">!</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span>          <span class="c1">// Applies p</span>
</span><span class='line'>        <span class="k">let</span><span class="o">!</span> <span class="n">xs</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Many</span> <span class="n">p</span><span class="o">)</span>  <span class="c1">// Applies (Many p) recursively</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>      <span class="c1">// returns the cons of the two results</span>
</span><span class='line'>    <span class="o">}</span> <span class="o">&lt;|&gt;</span> <span class="nc">Return</span> <span class="bp">[]</span>
</span></code></pre></td></tr></table></div></figure>


<p>or the following <code>Many1</code> combinator, which is similar to the <code>Many</code> combinator but requires at least one success (Think of <code>*</code> vs <code>+</code> in regular expressions):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="nc">Many1</span> <span class="n">p</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="kt">list</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">parse</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">let</span><span class="o">!</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span>          <span class="c1">// Applies p</span>
</span><span class='line'>        <span class="k">let</span><span class="o">!</span> <span class="n">xs</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Many</span> <span class="n">p</span><span class="o">)</span>  <span class="c1">// Applies (Many p) recursively</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>      <span class="c1">// returns the cons of the two results</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>or even more complex parsers such a this floating point number parser:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// Parses float numbers which match /[+-]?(\d+(\.\d*)?|\d*\.\d+)([eE][+-]?\d+)?/</span>
</span><span class='line'><span class="k">let</span> <span class="nc">FloatParser</span><span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">parse</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">let</span><span class="o">!</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">CharParser</span> <span class="sc">&#39;+&#39;</span> <span class="o">&lt;|&gt;</span> <span class="nc">CharParser</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="o">&lt;|&gt;</span> <span class="nc">Return</span> <span class="sc">&#39;+&#39;</span>     <span class="c1">// [+-]?</span>
</span><span class='line'>        <span class="k">let</span><span class="o">!</span> <span class="n">l</span> <span class="o">=</span> <span class="o">(</span><span class="n">parse</span> <span class="o">{</span>                                               <span class="c1">// (</span>
</span><span class='line'>            <span class="k">let</span><span class="o">!</span> <span class="n">l</span> <span class="o">=</span> <span class="nc">Many1</span> <span class="nc">DigitParser</span>                                  <span class="c1">//   \d+</span>
</span><span class='line'>            <span class="k">let</span><span class="o">!</span> <span class="n">pd</span> <span class="o">=</span> <span class="o">(</span><span class="n">parse</span> <span class="o">{</span>                                          <span class="c1">//   (</span>
</span><span class='line'>                <span class="k">let</span><span class="o">!</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">CharParser</span> <span class="sc">&#39;.&#39;</span>                                 <span class="c1">//     \.</span>
</span><span class='line'>                <span class="k">let</span><span class="o">!</span> <span class="n">d</span> <span class="o">=</span> <span class="nc">Many</span> <span class="nc">DigitParser</span>                               <span class="c1">//     \d*</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">p</span><span class="o">::</span><span class="n">d</span>
</span><span class='line'>                <span class="o">}</span> <span class="o">&lt;|&gt;</span> <span class="nc">Return</span> <span class="bp">[]</span><span class="o">)</span>                                        <span class="c1">//   )?</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">l</span> <span class="o">@</span> <span class="n">pd</span>
</span><span class='line'>            <span class="o">}</span> <span class="o">&lt;|&gt;</span>                                                       <span class="c1">//   |</span>
</span><span class='line'>            <span class="n">parse</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">let</span><span class="o">!</span> <span class="n">l</span> <span class="o">=</span> <span class="nc">Many</span> <span class="nc">DigitParser</span>                               <span class="c1">//   \d*</span>
</span><span class='line'>                <span class="k">let</span><span class="o">!</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">CharParser</span> <span class="sc">&#39;.&#39;</span>                                 <span class="c1">//   \.</span>
</span><span class='line'>                <span class="k">let</span><span class="o">!</span> <span class="n">d</span> <span class="o">=</span> <span class="nc">Many1</span> <span class="nc">DigitParser</span>                              <span class="c1">//   \d+</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">l</span> <span class="o">@</span> <span class="n">p</span><span class="o">::</span><span class="n">d</span>
</span><span class='line'>            <span class="o">}</span>                                                           <span class="c1">// )</span>
</span><span class='line'>        <span class="o">)</span>
</span><span class='line'>        <span class="k">let</span><span class="o">!</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">parse</span> <span class="o">{</span>                                               <span class="c1">// (</span>
</span><span class='line'>            <span class="k">let</span><span class="o">!</span> <span class="n">e</span> <span class="o">=</span> <span class="nc">CharParser</span> <span class="sc">&#39;e&#39;</span> <span class="o">&lt;|&gt;</span> <span class="nc">CharParser</span> <span class="sc">&#39;E&#39;</span>                  <span class="c1">//   [eE]</span>
</span><span class='line'>            <span class="k">let</span><span class="o">!</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">CharParser</span> <span class="sc">&#39;+&#39;</span> <span class="o">&lt;|&gt;</span> <span class="nc">CharParser</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="o">&lt;|&gt;</span> <span class="nc">Return</span> <span class="sc">&#39;+&#39;</span> <span class="c1">//   [+-]?</span>
</span><span class='line'>            <span class="k">let</span><span class="o">!</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Many1</span> <span class="o">(</span><span class="nc">DigitParser</span><span class="o">)</span>                                <span class="c1">//   \d+</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">e</span><span class="o">::</span><span class="n">s</span><span class="o">::</span><span class="n">x</span>                                              <span class="c1">// )?</span>
</span><span class='line'>        <span class="o">}</span> <span class="o">&lt;|&gt;</span> <span class="nc">Return</span> <span class="bp">[]</span><span class="o">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="kt">float</span> <span class="o">(</span><span class="k">new</span> <span class="nn">System</span><span class="p">.</span><span class="nc">String</span><span class="o">(</span><span class="n">s</span><span class="o">::(</span><span class="n">l</span> <span class="o">@</span> <span class="n">e</span><span class="o">)</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">toArray</span><span class="o">))</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>which allows us to do the following parsing:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="o">&gt;</span> <span class="n">printfn</span> <span class="s2">&quot;%A&quot;</span> <span class="o">(</span><span class="nc">FloatParser</span> <span class="o">(</span><span class="s2">&quot;-1.23e45&quot;</span> <span class="o">|&gt;</span> <span class="nn">Seq</span><span class="p">.</span><span class="n">toList</span><span class="o">));;</span>
</span><span class='line'><span class="nc">Success</span> <span class="o">(-</span><span class="mi">1</span><span class="o">.</span><span class="mi">23</span><span class="n">e</span><span class="o">+</span><span class="mi">45</span><span class="o">,</span><span class="bp">[]</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Imagine if we had to write the previous parser with nested <code>&gt;&gt;=</code> operators&#8230;</p>

<h3>Conclusion</h3>

<p>I think we can summarize the post in the following points:</p>

<ul>
<li>The word <em>monad</em> is cool but gives no clue of what they actually are. Other languages have chosen more descriptive names such as <em>workflows</em>.</li>
<li>A monad is just an <a href="http://en.wikipedia.org/wiki/Interface_%28Java%29"><em>interface</em></a> with certain rules in the implementation of its methods.</li>
<li>Parser combinators are a good example of the usage of monads.</li>
<li>Monads without the <em>do-notation</em> would be a pain in the ass.</li>
</ul>


<p>All the code snippets are available <a href="http://tryfs.net/snippets/snippet-hB">here</a> for easy access and testing.</p>

<p><em>Wow, that was long.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to parser combinators]]></title>
    <link href="http://santialbo.com/blog/2013/03/24/introduction-to-parser-combinators/"/>
    <updated>2013-03-24T23:45:00+01:00</updated>
    <id>http://santialbo.com/blog/2013/03/24/introduction-to-parser-combinators</id>
    
    <category><![CDATA[F#]]></category>
    
    <category><![CDATA[Functional programming]]></category>
    
    <category><![CDATA[Parser combinators]]></category>
    
    
    
    <summary><![CDATA[So I have been playing with parser combinators for quite a while now and they felt so interesting that I wanted to write about them. What is a parser? Basically a parser is a function which accepts some sort of character input such a string or a character stream and &hellip;]]></summary>
    
    <content type="html"><![CDATA[<p>So I have been playing with parser combinators for quite a while now and they felt so interesting that I wanted to write about them.</p>

<h3>What is a parser?</h3>

<p>Basically a parser is a function which accepts some sort of character input such a string or a character stream and returns some structure as output that contains the parsed result. It is as simple as it sounds, no intricacies here.</p>

<p>Parsers are used everywhere in software in order to interpret character sequences into complex structures. Some simple example are JSON and XML parsers, which take some string as argument and return the corresponding data structure.</p>

<p>Using F#, we can define a simple parser type as follows:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">ParserResult</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Success</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="kt">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Failure</span>
</span><span class='line'>
</span><span class='line'><span class="k">type</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="nc">ParserResult</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This means that a <code>Parser</code> will receive a <code>list&lt;char&gt;</code> and will return a <code>ParserResult&lt;'a&gt;</code> which can be either a <code>Failure</code> if nothing could be parsed or a <code>Success</code> otherwise and return both the parsed element and the rest of the list.</p>

<!--more-->


<p>Having this definition, we can now build our first parser:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// If the stream starts with c, returns Success, otherwise returns Failure</span>
</span><span class='line'><span class="k">let</span> <span class="nc">CharParser</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="kt">char</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">p</span> <span class="n">stream</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">match</span> <span class="n">stream</span> <span class="k">with</span>
</span><span class='line'>        <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="k">when</span> <span class="n">x</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span>
</span><span class='line'>        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Failure</span>
</span><span class='line'>    <span class="k">in</span> <span class="n">p</span>
</span></code></pre></td></tr></table></div></figure>


<p>which whill check if the given list starts with the specified element and if it does, returns a <code>Success</code> with both the element and the rest of the list. If it doesn&#8217;t, it returns a <code>Failure</code>.</p>

<p><em>Wait&#8230; what? Is that a parser?</em></p>

<p>Yes! and is probably one of the most important. Here is how it works:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="o">&gt;</span> <span class="o">(</span><span class="nc">CharParser</span> <span class="sc">&#39;a&#39;</span><span class="o">)</span> <span class="o">[</span><span class="sc">&#39;a&#39;</span><span class="o">;</span> <span class="sc">&#39;b&#39;</span><span class="o">;</span> <span class="sc">&#39;c&#39;</span><span class="o">]</span>
</span><span class='line'><span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="nc">ParserResult</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nc">Success</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,[</span><span class="sc">&#39;b&#39;</span><span class="o">;</span> <span class="sc">&#39;c&#39;</span><span class="o">])</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;</span> <span class="o">(</span><span class="nc">CharParser</span> <span class="sc">&#39;b&#39;</span><span class="o">)</span> <span class="o">[</span><span class="sc">&#39;a&#39;</span><span class="o">;</span> <span class="sc">&#39;b&#39;</span><span class="o">;</span> <span class="sc">&#39;c&#39;</span><span class="o">]</span>
</span><span class='line'><span class="k">val</span> <span class="n">it</span> <span class="o">:</span> <span class="nc">ParserResult</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nc">Failure</span>
</span></code></pre></td></tr></table></div></figure>


<p>Simple and stupid by itself, but useful when used as a building block for more complex parsers.</p>

<p><em>Ok, you showed what a parser is, what are those parser combinators you mention in the title?</em></p>

<h3>Gluing parsers with parser combinators</h3>

<p>A parser combinator is a <a href="http://en.wikipedia.org/wiki/Higher-order_function">higher order function</a> that operates on one or more parsers in order to create a new parser.</p>

<p>Basically, parser combinators are the glue that allows us to mix small and simple parser in order to create more complex parsers that eventually, will allow us to parse whatever it is we want to parse.</p>

<p>We could, for example, define the following <code>Either</code> parser combinator:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// If p1 fails uses p2, otherwise returns p1&#39;s result</span>
</span><span class='line'><span class="k">let</span> <span class="nc">Either</span> <span class="o">(</span><span class="n">p1</span><span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">p2</span><span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;)</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">p</span> <span class="n">stream</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">match</span> <span class="n">p1</span> <span class="n">stream</span> <span class="k">with</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">Failure</span> <span class="o">-&gt;</span> <span class="n">p2</span> <span class="n">stream</span>
</span><span class='line'>        <span class="o">|</span> <span class="n">res</span> <span class="o">-&gt;</span> <span class="n">res</span>
</span><span class='line'>    <span class="k">in</span> <span class="n">p</span>
</span></code></pre></td></tr></table></div></figure>


<p>which builds a new parser that will try to use the first input parser and, if it fails, will use the second.</p>

<p>Imagine now, we would like to build a digit parser. Now that we have defined our <code>Either</code> operator we could define the parser as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// Parses any digit character</span>
</span><span class='line'><span class="k">let</span> <span class="nc">DigitParser</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="o">[</span><span class="sc">&#39;0&#39;</span><span class="o">..</span><span class="sc">&#39;9&#39;</span><span class="o">]</span>
</span><span class='line'>    <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="nc">CharParser</span>
</span><span class='line'>    <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">reduce</span> <span class="nc">Either</span>
</span></code></pre></td></tr></table></div></figure>


<p>What if we wanted that parser to return an <code>int</code> instead? We could simply define our second parser combinator:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// Applies the function f to the result of p if it succeeds</span>
</span><span class='line'><span class="k">let</span> <span class="nc">Apply</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">q</span> <span class="n">stream</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">match</span> <span class="n">p</span> <span class="n">stream</span> <span class="k">with</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">Failure</span> <span class="o">-&gt;</span> <span class="nc">Failure</span>
</span><span class='line'>    <span class="k">in</span> <span class="n">q</span>
</span></code></pre></td></tr></table></div></figure>


<p>and now we could use it to define a new digit parser:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="nc">DigitParserInt</span> <span class="o">=</span> <span class="nc">Apply</span> <span class="nc">DigitParser</span> <span class="o">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="kt">int</span> <span class="sc">&#39;0&#39;</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>But parsing only a single character is not very useful so we could build the following combinator</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// Applies p as many times as possible</span>
</span><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="nc">Many</span> <span class="o">(</span><span class="n">p</span><span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;)</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">q</span> <span class="n">stream</span> <span class="o">=</span>
</span><span class='line'>        <span class="k">match</span> <span class="n">p</span> <span class="n">stream</span> <span class="k">with</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">Failure</span> <span class="o">-&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="bp">[]</span><span class="o">,</span> <span class="n">stream</span><span class="o">)</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="o">-&gt;</span>  <span class="o">(</span><span class="nc">Apply</span> <span class="o">(</span><span class="nc">Many</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span><span class="o">))</span> <span class="n">rest</span>
</span><span class='line'>    <span class="k">in</span> <span class="n">q</span>
</span></code></pre></td></tr></table></div></figure>


<p>which will run the input parser <code>p</code> as many times as possible until it fails and will return a list of the successfully parsed elements.</p>

<p>This new combinator allows us to build the following integer parser:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="c1">/// Parses (positive) integer numbers</span>
</span><span class='line'><span class="k">let</span> <span class="nc">IntegerParser</span> <span class="o">:</span> <span class="nc">Parser</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span>
</span><span class='line'>    <span class="nc">Apply</span> <span class="o">(</span><span class="nc">Many</span> <span class="nc">DigitParserInt</span><span class="o">)</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">reduce</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">y</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>that will parse integer numbers.</p>

<h3>Enough</h3>

<p>We could go like this forever but fortunately smarter people did it before and made their work freely available. The most famous library is <a href="http://www.haskell.org/haskellwiki/Parsec">Parsec</a> for Haskell but <a href="http://www.haskell.org/haskellwiki/Parsec#Parsec_clones_in_other_languages">adaptations have been made to other languages</a> including C++, Java, Python, Javascript among many.</p>

<p>I myself have written a <a href="https://github.com/santialbo/ParserCombinators">small library in F#</a> for the sake of learning and I used it to build a JSON parser. I think it can be a nice introduction parser combinators since it is not optimized in any way and the ideas can be seen more clearly.</p>

<p>I posted all the code snippets of this post <a href="http://tryfs.net/snippets/snippet-hw">here</a> to make it possible to try them online.</p>

<p>In my next post I will talk about monads in F# and explain how parser combinators is probably one of the better examples to understand what they are.</p>
]]></content>
  </entry>
  
</feed>
